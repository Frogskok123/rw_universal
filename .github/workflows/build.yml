name: Build Advanced LKM with IOCTL

on:
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup
        run: |
          sudo apt-get update
          sudo apt-get install -y bc bison build-essential flex git libelf-dev libssl-dev gcc-aarch64-linux-gnu

      - name: Clone Kernel
        run: |
          git clone --depth=1 https://android.googlesource.com/kernel/common -b android12-5.10 kernel

      - name: Create Module
        run: |
          cat > rw_universal.c << 'ENDCODE'
          #define pr_fmt(fmt) "rw_drv: " fmt
          #include <linux/init.h>
          #include <linux/module.h>
          #include <linux/kernel.h>
          #include <linux/fs.h>
          #include <linux/uaccess.h>
          #include <linux/mm.h>
          #include <linux/kallsyms.h>
          #include <linux/kprobes.h>
          #include <linux/sched.h>
          #include <linux/sched/signal.h>
          #include <linux/pagewalk.h>
          #include <linux/pid.h>
          #include <linux/device.h>
          #include <linux/slab.h>
          #include <asm/pgtable.h>

          MODULE_LICENSE("GPL");
          MODULE_AUTHOR("x");
          MODULE_DESCRIPTION("Advanced R/W Driver");
          MODULE_INFO(vermagic, "5.10.136-android12-9-g70d5edde7d3a SMP preempt mod_unload modversions aarch64");

          #define DEVICE_NAME "video188"
          #define CLASS_NAME "rw_class"

          // IOCTL команды (совпадают с вашими)
          #define OP_INIT_KEY         0x800
          #define OP_READ_MEM         0x801
          #define OP_WRITE_MEM        0x802
          #define OP_MODULE_BASE      0x803
          #define OP_HIDE_PROCESS     0x804
          #define OP_PID_HIDE_PROCESS 0x805
          #define OP_GET_PROCESS_PID  0x806

          // Структуры (совпадают с вашими)
          typedef struct _COPY_MEMORY {
              pid_t pid;
              unsigned long addr;
              void __user *buffer;
              size_t size;
          } COPY_MEMORY;

          typedef struct _MODULE_BASE {
              pid_t pid;
              char __user *name;
              unsigned long base;
          } MODULE_BASE;

          typedef struct _PROCESS {
              pid_t process_pid;
              char __user *process_comm;
          } PROCESS;

          static int major_number;
          static struct class *dev_class = NULL;
          static struct device *dev_device = NULL;
          static struct mm_struct *init_mm_ptr = NULL;
          static char auth_key[256] = {0};

          // === Symbol resolver ===
          static unsigned long resolve_ksym(const char *name) {
              struct kprobe kp = { .symbol_name = name };
              unsigned long addr;
              if (register_kprobe(&kp) < 0) return 0;
              addr = (unsigned long)kp.addr;
              unregister_kprobe(&kp);
              return addr;
          }

          // === Memory operations ===
          typedef struct { phys_addr_t phys; bool valid; } v2p_t;

          static int walker(pte_t *pte, unsigned long addr, unsigned long next, struct mm_walk *walk) {
              v2p_t *v = walk->private;
              if (pte_present(*pte)) {
                  v->phys = (pte_pfn(*pte) << PAGE_SHIFT) | (addr & ~PAGE_MASK);
                  v->valid = true;
                  return 1;
              }
              return 0;
          }

          static const struct mm_walk_ops v2p_walk_ops = { .pte_entry = walker };

          static phys_addr_t virt_to_phys_custom(struct mm_struct *mm, unsigned long vaddr) {
              v2p_t res = {0};
              if (!mm) mm = init_mm_ptr;
              walk_page_range(mm, vaddr, vaddr + 1, &v2p_walk_ops, &res);
              return res.valid ? res.phys : 0;
          }

          static int read_process_memory(pid_t pid, unsigned long addr, void __user *buffer, size_t size) {
              struct task_struct *task;
              struct mm_struct *mm;
              void *kbuf;
              unsigned long offset;
              size_t copy_size;
              int ret = 0;

              task = pid_task(find_vpid(pid), PIDTYPE_PID);
              if (!task) return -ESRCH;

              mm = get_task_mm(task);
              if (!mm) return -EINVAL;

              kbuf = kmalloc(size, GFP_KERNEL);
              if (!kbuf) {
                  mmput(mm);
                  return -ENOMEM;
              }

              while (size > 0) {
                  phys_addr_t phys = virt_to_phys_custom(mm, addr);
                  if (!phys) {
                      ret = -EFAULT;
                      break;
                  }

                  offset = addr & ~PAGE_MASK;
                  copy_size = min(size, PAGE_SIZE - offset);

                  memcpy(kbuf, phys_to_virt(phys), copy_size);
                  
                  addr += copy_size;
                  size -= copy_size;
              }

              if (ret == 0 && copy_to_user(buffer, kbuf, copy_size))
                  ret = -EFAULT;

              kfree(kbuf);
              mmput(mm);
              return ret;
          }

          static int write_process_memory(pid_t pid, unsigned long addr, void __user *buffer, size_t size) {
              struct task_struct *task;
              struct mm_struct *mm;
              void *kbuf;
              unsigned long offset;
              size_t copy_size;
              int ret = 0;

              task = pid_task(find_vpid(pid), PIDTYPE_PID);
              if (!task) return -ESRCH;

              mm = get_task_mm(task);
              if (!mm) return -EINVAL;

              kbuf = kmalloc(size, GFP_KERNEL);
              if (!kbuf) {
                  mmput(mm);
                  return -ENOMEM;
              }

              if (copy_from_user(kbuf, buffer, size)) {
                  kfree(kbuf);
                  mmput(mm);
                  return -EFAULT;
              }

              while (size > 0) {
                  phys_addr_t phys = virt_to_phys_custom(mm, addr);
                  if (!phys) {
                      ret = -EFAULT;
                      break;
                  }

                  offset = addr & ~PAGE_MASK;
                  copy_size = min(size, PAGE_SIZE - offset);

                  memcpy(phys_to_virt(phys), kbuf, copy_size);

                  addr += copy_size;
                  size -= copy_size;
              }

              kfree(kbuf);
              mmput(mm);
              return ret;
          }

          static unsigned long get_module_base_addr(pid_t pid, const char *name) {
              struct task_struct *task;
              struct mm_struct *mm;
              struct vm_area_struct *vma;
              unsigned long base = 0;

              task = pid_task(find_vpid(pid), PIDTYPE_PID);
              if (!task) return 0;

              mm = get_task_mm(task);
              if (!mm) return 0;

              for (vma = mm->mmap; vma; vma = vma->vm_next) {
                  if (vma->vm_file) {
                      char *path_buf = kmalloc(PATH_MAX, GFP_KERNEL);
                      if (path_buf) {
                          char *path = d_path(&vma->vm_file->f_path, path_buf, PATH_MAX);
                          if (!IS_ERR(path) && strstr(path, name)) {
                              base = vma->vm_start;
                              kfree(path_buf);
                              break;
                          }
                          kfree(path_buf);
                      }
                  }
              }

              mmput(mm);
              return base;
          }

          static pid_t get_process_pid_by_name(const char *name) {
              struct task_struct *task;
              pid_t found_pid = 0;

              rcu_read_lock();
              for_each_process(task) {
                  if (strcmp(task->comm, name) == 0) {
                      found_pid = task->pid;
                      break;
                  }
              }
              rcu_read_unlock();

              return found_pid;
          }

          // === IOCTL handler ===
          static long device_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {
              COPY_MEMORY cm;
              MODULE_BASE mb;
              PROCESS pc;
              char name_buf[256];
              int ret = 0;

              switch (cmd) {
                  case OP_INIT_KEY:
                      if (copy_from_user(auth_key, (void __user *)arg, sizeof(auth_key)))
                          return -EFAULT;
                      pr_info("Auth key initialized");
                      break;

                  case OP_READ_MEM:
                      if (copy_from_user(&cm, (void __user *)arg, sizeof(cm)))
                          return -EFAULT;
                      ret = read_process_memory(cm.pid, cm.addr, cm.buffer, cm.size);
                      break;

                  case OP_WRITE_MEM:
                      if (copy_from_user(&cm, (void __user *)arg, sizeof(cm)))
                          return -EFAULT;
                      ret = write_process_memory(cm.pid, cm.addr, cm.buffer, cm.size);
                      break;

                  case OP_MODULE_BASE:
                      if (copy_from_user(&mb, (void __user *)arg, sizeof(mb)))
                          return -EFAULT;
                      if (copy_from_user(name_buf, mb.name, sizeof(name_buf)))
                          return -EFAULT;
                      mb.base = get_module_base_addr(mb.pid, name_buf);
                      if (copy_to_user((void __user *)arg, &mb, sizeof(mb)))
                          return -EFAULT;
                      break;

                  case OP_GET_PROCESS_PID:
                      if (copy_from_user(&pc, (void __user *)arg, sizeof(pc)))
                          return -EFAULT;
                      if (copy_from_user(name_buf, pc.process_comm, sizeof(name_buf)))
                          return -EFAULT;
                      pc.process_pid = get_process_pid_by_name(name_buf);
                      if (copy_to_user((void __user *)arg, &pc, sizeof(pc)))
                          return -EFAULT;
                      break;

                  case OP_HIDE_PROCESS:
                      list_del_init(&current->tasks);
                      pr_info("Process hidden: %d", current->pid);
                      break;

                  case OP_PID_HIDE_PROCESS: {
                      pid_t target_pid;
                      struct task_struct *target;
                      if (copy_from_user(&target_pid, (void __user *)arg, sizeof(pid_t)))
                          return -EFAULT;
                      target = pid_task(find_vpid(target_pid), PIDTYPE_PID);
                      if (target) {
                          list_del_init(&target->tasks);
                          pr_info("Process %d hidden", target_pid);
                      }
                      break;
                  }

                  default:
                      return -EINVAL;
              }

              return ret;
          }

          static int device_open(struct inode *inode, struct file *file) {
              pr_info("Device opened");
              return 0;
          }

          static int device_release(struct inode *inode, struct file *file) {
              pr_info("Device closed");
              return 0;
          }

          static struct file_operations fops = {
              .open = device_open,
              .release = device_release,
              .unlocked_ioctl = device_ioctl,
              .compat_ioctl = device_ioctl,
          };

          static int __init rw_init(void) {
              pr_info("Loading advanced driver");

              init_mm_ptr = (void *)resolve_ksym("init_mm");
              if (!init_mm_ptr) {
                  pr_err("Failed to resolve init_mm");
                  return -ENODEV;
              }

              major_number = register_chrdev(0, DEVICE_NAME, &fops);
              if (major_number < 0) {
                  pr_err("Failed to register chrdev");
                  return major_number;
              }

              dev_class = class_create(THIS_MODULE, CLASS_NAME);
              if (IS_ERR(dev_class)) {
                  unregister_chrdev(major_number, DEVICE_NAME);
                  pr_err("Failed to create class");
                  return PTR_ERR(dev_class);
              }

              dev_device = device_create(dev_class, NULL, MKDEV(major_number, 0), NULL, DEVICE_NAME);
              if (IS_ERR(dev_device)) {
                  class_destroy(dev_class);
                  unregister_chrdev(major_number, DEVICE_NAME);
                  pr_err("Failed to create device");
                  return PTR_ERR(dev_device);
              }

              pr_info("Driver loaded: /dev/%s (major: %d)", DEVICE_NAME, major_number);
              return 0;
          }

          static void __exit rw_exit(void) {
              device_destroy(dev_class, MKDEV(major_number, 0));
              class_destroy(dev_class);
              unregister_chrdev(major_number, DEVICE_NAME);
              pr_info("Driver unloaded");
          }

          module_init(rw_init);
          module_exit(rw_exit);
          ENDCODE
          
          echo "obj-m := rw_universal.o" > Makefile

      - name: Build
        run: |
          export ARCH=arm64
          export CROSS_COMPILE=aarch64-linux-gnu-
          cd kernel
          make defconfig
          scripts/config --enable MODULES
          scripts/config --enable MODULE_UNLOAD
          scripts/config --enable MODVERSIONS
          scripts/config --disable MODULE_SIG
          scripts/config --set-str LOCALVERSION "-android12-9-g70d5edde7d3a"
          make olddefconfig
          make kernelrelease
          make modules_prepare
          cd ..
          make -C kernel M=$PWD modules
          modinfo rw_universal.ko | grep vermagic
          ls -lh rw_universal.ko

      - name: Upload
        uses: actions/upload-artifact@v4
        with:
          name: rw_universal-ioctl
          path: rw_universal.ko
